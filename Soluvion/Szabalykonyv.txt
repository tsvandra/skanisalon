================================================================================
PROJEKT STATUS & SZABÁLYKÖNYV: SOLUVION (SKANI SALON)
================================================================================
Dátum:    2026.02.09.
Státusz:  MVP Stabilizálás (SaaS Transition Phase)

[ CÉL ]
Ez a dokumentum rögzíti az elért eredményeket, a követendő kódolási szabályokat 
és a megoldott technikai akadályokat. Minden jövőbeli fejlesztésnek ehhez 
kell igazodnia ("Single Source of Truth").

--------------------------------------------------------------------------------

[ 1. ARCHITEKTÚRÁLIS ALAPELVEK (A "TÖRVÉNYEK") ]

1. SaaS & Multi-tenant (Többcéges) Működés
   - Frontend: SOHA nem égetünk be fix ID-t (pl. 7).
     > Látogatók: URL paraméter (?id=8) vagy App.vue default inject.
     > Admin: A JWT Tokenben lévő 'CompanyId' az irányadó.
   
   - Backend: SOHA nem bízunk a kliens által küldött ID-ban írási műveleteknél.
     > Kötelező: User.FindFirst("CompanyId") claim használata.
     > Tenant Isolation: Minden lekérdezést szűrni kell: 
        .Where(x => x.CompanyId == currentCompanyId)

2. API Kommunikáció
   - Frontend: TILOS a 'fetch' használata manuális header építéssel!
     > Megoldás: Kizárólag a 'src/services/api.js' Axios példány használható.
     > Ok: Automatikusan kezeli a BaseURL-t és a Bearer tokent.
     > Kivétel: Képfeltöltés (FormData) -> { headers: { 'Content-Type': undefined } }

3. Környezeti Változók (.env)
   - A backend URL sosem lehet hardcoded.
   - Helyes formátum: VITE_API_URL=https://...
   - Hivatkozás: import.meta.env.VITE_API_URL

4. Adatkonzisztencia és UX (Race Conditions)
   - Gyors adatbevitelű mezőknél (pl. InputNumber, Textarea) a szerver válasza ("Response")
     NEM írhatja felül automatikusan a Frontend lokális állapotát.
   - Kivétel: Ha strukturális változás történt (pl. új ID generálása).
   - Cél: A lassabb hálózat miatti villogás és adatvesztés elkerülése gépelés közben.

5. Aszinkron Adatmentés (Race Condition Védelem)
   - Probléma: Gyors felhasználói bevitelkor (pl. InputNumber) a párhuzamos API kérések 
     eltérő sorrendben érhetnek be, felülírva a friss adatot régivel.
   - Megoldás: "Request Queue" (Promise Chain) alkalmazása a komponensben.
   - Szabály: Minden mentési kérést sorba kell állítani (await prevPromise).
   - Input kezelés: PrimeVue komponenseknél a biztos mentés érdekében:
     @update:modelValue="save(..., false)" ÉS @blur="save(..., false)" együtt használandó.

--------------------------------------------------------------------------------

[ 2. KÓDOLÁSI ELVEK (CLEAN CODE) ]

1. Clean Code vs. Érthetőség
   - Törekedj a tiszta, karbantartható kódra (DRY, SOLID, naming conventions).
   - Soha ne menjen a könnyű értelmezhetőség rovására.
   - Kerüld a túlzott túlmérnöklést (Over-engineering).

2. Code Review (Önellenőrzés)
   - Mielőtt egy feladatot késznek jelzünk (git push előtt), mindig ellenőrizd:
     van-e lehetőség refaktorálásra vagy egyszerűsítésre?

3. Megjegyzések
   - A kód legyen önmagáért beszélő.
   - Ahol szükséges, használj kommentezést a "miért" magyarázatára (nem a "mit").

--------------------------------------------------------------------------------

[ 3. ELKÉSZÜLT MODULOK ÉS MEGOLDOTT PROBLÉMÁK ]

1. Autentikáció (Auth Module)
   - Eredmény: Biztonságos regisztráció, Login, JWT + BCrypt.
   - Refaktor: Logika kiszervezve a Controllerből a 'Services/AuthService.cs'-be.
   - Tanulság: "Thin Controller" elv alkalmazása.

2. Cégbeállítások (Company Module)
   - Eredmény: Dinamikus stílusok (CSS változók) és adatok.
   - Megoldás:
     > Frontend: 'provide/inject' minta az adatok leosztására.
     > Backend: DTO-k (UpdateCompanyDto) a Mass Assignment elkerülésére.

3. Árlista és Szolgáltatások (Services Module) - REFAKTORÁLVA
   - Eredmény: Drag-and-Drop rendezés, Kategóriák kezelése, Sötét téma (Dark Mode).
   - Megoldás:
     > Frontend: 'vuedraggable' használata, Nested (Hierarchikus) adatstruktúra.
     > Adatmodell: Kategória alapú csoportosítás, Megjegyzés (Description) mező bevezetése.
     > Mentés: 'refreshLocal' logika a Race Condition kiküszöbölésére.

4. Galéria és Fájlkezelés (Gallery Module)
   - Eredmény: Képfeltöltés, Kategóriák, Fizikai törlés.
   - Megoldott Hiba (Backend 500): Hiányzó 'AddHttpContextAccessor' pótolva.
   - Megoldott Hiba (Frontend 415): Axios Content-Type felülbírálása.
   - SaaS Isolation: Képek mentése ID szerinti almappákba (images/{id}/).

--------------------------------------------------------------------------------

[ 4. INFRASTRUKTÚRA ÉS KONFIGURÁCIÓ ]

1. Backend (Program.cs Sorrend - KRITIKUS)
   A Middleware-ek sorrendje, ami jelenleg működik:
   1. Hibakezelés (app.Use...)
   2. app.UseCors("AllowAll")
   3. app.UseStaticFiles()        <-- Képekhez elengedhetetlen!
   4. app.UseAuthentication()
   5. app.UseAuthorization()
   6. app.MapControllers()

2. Frontend (Vue 3 Composition API)
   - Szintaxis: <script setup> mindenhol.
   - State: ref, computed, watch.
   - Global: provide (App.vue) -> inject (gyerek komponensek).
   - Libs: vuedraggable (Drag & Drop), PrimeVue.

--------------------------------------------------------------------------------

[ 5. KÖVETKEZŐ LÉPÉSEK (ROADMAP) ]

A "Front Office" (Látogatói oldal) teljes dinamizálása a cél:


1. HomeView.vue:
   - Fix "Lorem Ipsum" és címek cseréje adatbázisból jövő mezőkre.
   - (Description, OpeningHoursTitle)

2. ContactView.vue:
   - Térkép (MapEmbedUrl), Cím, Telefon, Email dinamizálása.
   - Nyitvatartás táblázat renderelése az adatbázisból.

3. Deploy:
   - A módosítások élesítése Railway (Backend) és Netlify (Frontend) oldalon.

--------------------------------------------------------------------------------

[ 6. ÚJ FEJLESZTÉSI SZABÁLYOK (2026-02-10) ]

1. DATA TRANSFER OBJECTS (DTO-k)
   - Tilos DTO osztályokat közvetlenül a Controller fájlokban definiálni.
   - Minden DTO-t külön fájlban, a `Models` (vagy `DTOs`) mappában kell elhelyezni.
   - Ok: A szintaktikai hibák elkerülése és a Controllerek átláthatóságának megőrzése.

2. ASZINKRON ÁLLAPOTKEZELÉS (Queueing)
   - Olyan funkcióknál, amelyek gyors, egymás utáni API hívásokat generálnak (pl. Drag-and-Drop rendezés, Csúszkák húzása), KÖTELEZŐ a `useAutoSaveQueue` composable használata.
   - Soha ne engedjünk párhuzamos API hívásokat ugyanarra az erőforrásra a versenyhelyzetek elkerülése végett.

3. SEPARATION OF CONCERNS (Admin UI)
   - A "Site Builder" jellegű funkciók (Logó feltöltés, Layout módosítás) helye a `SettingsView`-ban van.
   - Kerüljük a szerkesztő gombok elhelyezését közvetlenül a globális layout komponenseken (Header/Footer), hogy a napi felhasználói felület tiszta maradjon.
   - Használjuk a reaktív `provide/inject` mintát a beállítások azonnali érvényesítéséhez az alkalmazásban.

4. FELHŐ TÁROLÁS (CLOUD STORAGE)
   - Felhasználó által feltöltött médiafájlokat TILOS lokálisan a `wwwroot`-ban tárolni.
   - Minden médiafájlt a Cloudinary-ba (vagy egyéb felhő tárhelyre) kell feltölteni.
   - Az adatbázisban a `PublicId`-t is tárolni kell az `Url` mellett, a fájlok későbbi törölhetősége érdekében.


--------------------------------------------------------------------------------

[ 7.AI FEJLESZTÉSI SZABÁLYOK]

1. API Kulcs Biztonság:
   TILOS API kulcsot (sk-...) kódban vagy config fájlban commitolni. 
   Ha véletlenül megtörténik, a kulcsot azonnal vissza kell vonni és a Git history-t tisztítani (soft reset).

2. Prompt Logika (SaaS Rule):
   TILOS hard-coded üzleti típusokat (pl. "Fodrászat") írni a System Promptba. 
   Mindig a `CompanyType` változót kell behelyettesíteni, hogy a rendszer skálázható maradjon.

3. Frontend Hívás:
   Az AI fordítás mindig "On-Demand" (gombnyomásra) történik, sosem automatikusan a háttérben.
   A Frontendnek KÖTELEZŐ küldenie a `context` paramétert ('service', 'gallery', 'inventory'), 
   különben a backend "general" módban fordít, ami pontatlan lehet.

--------------------------------------------------------------------------------

[ 8. LOKALIZÁCIÓS ÉS UI SZABÁLYOK (2026.02.16) ]

1.  Nyelvi Fájlok Tilalma:
    TILOS fizikai JSON fájlt létrehozni új nyelveknek (pl. en.json, sk.json). 
    Kizárólag a `hu.json` létezhet fizikailag, minden más nyelvet a Store-nak kell generálnia runtime a DB-ből.

2.  UI Szövegek Kezelése:
    Minden statikus szöveget (gomb, label, placeholder) a `hu.json`-ba kell felvenni.
    TILOS hard-coded stringeket hagyni a .vue fájlokban (kivéve tesztelés alatt).

3.  PrimeVue v4 Kompatibilitás:
    Új komponensek írásakor vagy refaktoráláskor TILOS a régi PrimeVue v3 elnevezéseket használni.
    - Helyes: `<Select>`, `<Tabs>`, `<AccordionPanel>`.
    - Helytelen: `<Dropdown>`, `<TabView>`, `<AccordionTab>`.

4.  Aszinkron Folyamatok UI Visszajelzése:
    Ha egy folyamat (pl. AI fordítás) 1 másodpercnél tovább tart:
    - A szervernek azonnal vissza kell térnie `Accepted (202)` státusszal.
    - A kliensnek Polling mechanizmussal vagy WebSocket-tel kell figyelnie a státuszt.
    - Kötelező a Progress Bar vagy Spinner használata a felhasználó tájékoztatására.

--------------------------------------------------------------------------------

[ 9. ÚJ FEJLESZTÉSI SZABÁLYOK KIEGÉSZÍTÉS (2026-02-18) ]

1.  CONTROLLER HIGIÉNIA (Strict Mode)
    - TILOS DTO osztályokat, Enumokat vagy segédosztályokat a Controller fájlon belül definiálni, még ideiglenesen sem!
    - Minden új adatstruktúrának azonnal létre kell hozni a saját fájlját a `Models/DTOs` mappában.
    - Ha egy Controller meghaladja a 200 sort vagy túl sok felelőssége van (pl. Mock logika), a logikát ki kell szervezni egy Service osztályba.

2.  ADATBÁZIS ELNEVEZÉSEK
    - Kulcs-érték párokat tároló tábláknál a kulcs mező neve legyen konzisztensen `TranslationKey` (vagy `ConfigKey`), kerüljük a generikus `Key` elnevezést, mert az az Entity Frameworkben és a C# kulcsszavaknál is ütközést okozhat.